import * as fs from 'fs';
import { Atom } from './atom';
const protonPath = '/users/johnm/git-projects/personal/productivity/@obsidian/jcm-test/01 Brain/Protons';
const valuePath = '/users/johnm/git-projects/personal/productivity/@obsidian/jcm-test/02 Action/05 Values';
const testAtomPath = '/users/johnm/git-projects/personal/productivity/@obsidian/jcm-test/01 Brain/Atoms';
const singleTestAtomPath = '/users/johnm/git-projects/personal/productivity/@obsidian/jcm-test/01 Brain/Atoms/Boiling Frog Effect.md';
const maxAtomsToProcess = 20;
const addReverseFlashcardToAtom = (filePath) => {
    const fileName = filePath.split('/').pop() || '';
    const fileContent = fs.readFileSync(filePath, 'utf8');
    const atom = new Atom({});
    atom.populateFromFile(fileName, fileContent);
    const reverseFlashcard = atom.generateReverseFlashcardSection();
    fs.appendFileSync(filePath, reverseFlashcard, 'utf8');
};
const testSingleAtom = (path) => {
    const fileName = path.split('/').pop() || '';
    //updateAtomFlashcard(testAtomPath);
    const atom = new Atom({});
    const fileContent = fs.readFileSync(path, 'utf8');
    atom.populateFromFile(fileName, fileContent);
    console.log(atom);
    const rawDefinition = atom.rawDefinition();
    console.log(rawDefinition);
    const reverseFlashcard = atom.generateReverseFlashcardSection();
    console.log(reverseFlashcard);
};
const writeReverseFlashcards = () => {
    let counter = 0;
    fs.readdir(testAtomPath, (err, files) => {
        if (err) {
            console.error(err);
            return;
        }
        files.forEach(file => {
            let atomFilePath = `${testAtomPath}/${file}`;
            //console.log(atomFilePath);
            fs.stat(atomFilePath, (err, stats) => {
                if (err) {
                    console.error('Error getting stats:', err);
                    return;
                }
                if (!stats.isFile()) {
                    return;
                }
                else {
                    fs.readFile(atomFilePath, 'utf8', (err, fileContent) => {
                        if (err) {
                            console.error('Error reading the file:', err);
                            return;
                        }
                        const atom = new Atom({});
                        const fileName = atomFilePath.split('/').pop() || '';
                        console.log(fileName);
                        atom.populateFromFile(fileName, fileContent);
                        //console.log(atom)
                        const rawDefinition = atom.rawDefinition();
                        //console.log(rawDefinition);
                        if (atom.createReverseFlashcard && atom.reverseFlashcardInfo === '') {
                            if (counter < maxAtomsToProcess) {
                                const reverseFlashcard = atom.generateReverseFlashcardSection();
                                console.log(reverseFlashcard);
                                console.log(counter);
                                fs.appendFileSync(`${atomFilePath}`, `\n${reverseFlashcard}`, 'utf8');
                                counter += 1;
                            }
                            else {
                                console.log(`Max Atoms Processed.Skipping ${atomFilePath}`);
                            }
                        }
                        else {
                            console.log(`Skipping ${atomFilePath}`);
                        }
                    });
                }
            });
        });
    });
};
const updateAtoms = (atomPath) => {
    let counter = 0;
    fs.readdir(atomPath, (err, files) => {
        if (err) {
            console.error(err);
            return;
        }
        files.forEach(file => {
            let atomFilePath = `${atomPath}/${file}`;
            //console.log(atomFilePath);
            fs.stat(atomFilePath, (err, stats) => {
                if (err) {
                    console.error('Error getting stats:', err);
                    return;
                }
                if (!stats.isFile()) {
                    return;
                }
                else {
                    const fileContent = fs.readFileSync(atomFilePath, 'utf8');
                    const atom = new Atom({});
                    const fileName = atomFilePath.split('/').pop() || '';
                    console.log('##############');
                    console.log(fileName);
                    atom.populateFromFile(fileName, fileContent);
                    atom.writeToFile(atomFilePath);
                    //console.log(atom.generateAtomContent());
                }
            });
        });
    });
};
//const sectionTest = (atom: Atom) => {
//addReverseFlashcardToAtom(testAtomPath);
//testSingleAtom(singleTestAtomPath);
//writeReverseFlashcards();
updateAtoms(testAtomPath);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXRvbS9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUl6QixPQUFRLEVBQUUsSUFBSSxFQUFFLE1BQU0sUUFBUSxDQUFBO0FBSzlCLE1BQU0sVUFBVSxHQUFHLHFGQUFxRixDQUFBO0FBQ3hHLE1BQU0sU0FBUyxHQUFHLHdGQUF3RixDQUFBO0FBQzFHLE1BQU0sWUFBWSxHQUFHLG1GQUFtRixDQUFBO0FBQ3hHLE1BQU0sa0JBQWtCLEdBQUcsMEdBQTBHLENBQUE7QUFDckksTUFBTSxpQkFBaUIsR0FBRyxFQUFFLENBQUM7QUFJN0IsTUFBTSx5QkFBeUIsR0FBRyxDQUFDLFFBQWdCLEVBQUUsRUFBRTtJQUNuRCxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUNqRCxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQTtJQUNyRCxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUMxQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzdDLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLCtCQUErQixFQUFFLENBQUM7SUFDaEUsRUFBRSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDMUQsQ0FBQyxDQUFBO0FBRUQsTUFBTSxjQUFjLEdBQUcsQ0FBQyxJQUFZLEVBQUUsRUFBRTtJQUVwQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUM3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QUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztvQkFDckQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFBO29CQUM3QixPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUN0QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDO29CQUM3QyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDO29CQUUzQiwwQ0FBMEM7aUJBQ2pEO1lBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFBO0FBRUQsdUNBQXVDO0FBR3ZDLDBDQUEwQztBQUMxQyxxQ0FBcUM7QUFDckMsMkJBQTJCO0FBQzNCLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbi8vaW1wb3J0ICogYXMgeWFtbCBmcm9tICdqcy15YW1sJ1xuaW1wb3J0ICogYXMgbXl5YW1sIGZyb20gJy4veWFtbCdcbmltcG9ydCB7IGdldEFJU3VtbWFyeSB9IGZyb20gJy4uL2Nsb3VkL2F6dXJlJztcbmltcG9ydCAgeyBBdG9tIH0gZnJvbSAnLi9hdG9tJ1xuaW1wb3J0IHsgRmxhc2hjYXJkIH0gZnJvbSAnLi9mbGFzaGNhcmQnO1xuaW1wb3J0IHRlc3QgZnJvbSAnbm9kZTp0ZXN0JztcblxuXG5jb25zdCBwcm90b25QYXRoID0gJy91c2Vycy9qb2hubS9naXQtcHJvamVjdHMvcGVyc29uYWwvcHJvZHVjdGl2aXR5L0BvYnNpZGlhbi9qY20tdGVzdC8wMSBCcmFpbi9Qcm90b25zJ1xuY29uc3QgdmFsdWVQYXRoID0gJy91c2Vycy9qb2hubS9naXQtcHJvamVjdHMvcGVyc29uYWwvcHJvZHVjdGl2aXR5L0BvYnNpZGlhbi9qY20tdGVzdC8wMiBBY3Rpb24vMDUgVmFsdWVzJ1xuY29uc3QgdGVzdEF0b21QYXRoID0gJy91c2Vycy9qb2hubS9naXQtcHJvamVjdHMvcGVyc29uYWwvcHJvZHVjdGl2aXR5L0BvYnNpZGlhbi9qY20tdGVzdC8wMSBCcmFpbi9BdG9tcydcbmNvbnN0IHNpbmdsZVRlc3RBdG9tUGF0aCA9ICcvdXNlcnMvam9obm0vZ2l0LXByb2plY3RzL3BlcnNvbmFsL3Byb2R1Y3Rpdml0eS9Ab2JzaWRpYW4vamNtLXRlc3QvMDEgQnJhaW4vQXRvbXMvQm9pbGluZyBGcm9nIEVmZmVjdC5tZCdcbmNvbnN0IG1heEF0b21zVG9Qcm9jZXNzID0gMjA7XG5cblxuXG5jb25zdCBhZGRSZXZlcnNlRmxhc2hjYXJkVG9BdG9tID0gKGZpbGVQYXRoOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBmaWxlTmFtZSA9IGZpbGVQYXRoLnNwbGl0KCcvJykucG9wKCkgfHwgJyc7XG4gICAgY29uc3QgZmlsZUNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4JylcbiAgICBjb25zdCBhdG9tID0gbmV3IEF0b20oe30pO1xuICAgIGF0b20ucG9wdWxhdGVGcm9tRmlsZShmaWxlTmFtZSwgZmlsZUNvbnRlbnQpO1xuICAgIGNvbnN0IHJldmVyc2VGbGFzaGNhcmQgPSBhdG9tLmdlbmVyYXRlUmV2ZXJzZUZsYXNoY2FyZFNlY3Rpb24oKTtcbiAgICBmcy5hcHBlbmRGaWxlU3luYyhmaWxlUGF0aCwgcmV2ZXJzZUZsYXNoY2FyZCwgJ3V0ZjgnKTtcbn1cblxuY29uc3QgdGVzdFNpbmdsZUF0b20gPSAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgXG4gICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoLnNwbGl0KCcvJykucG9wKCkgfHwgJyc7XG4gICAgLy91cGRhdGVBdG9tRmxhc2hjYXJkKHRlc3RBdG9tUGF0aCk7XG4gICAgY29uc3QgYXRvbSA9IG5ldyBBdG9tKHt9KTtcbiAgICBjb25zdCBmaWxlQ29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLCAndXRmOCcpXG4gICAgYXRvbS5wb3B1bGF0ZUZyb21GaWxlKGZpbGVOYW1lLCBmaWxlQ29udGVudCk7XG4gICAgY29uc29sZS5sb2coYXRvbSlcbiAgICBjb25zdCByYXdEZWZpbml0aW9uID0gYXRvbS5yYXdEZWZpbml0aW9uKCk7XG4gICAgY29uc29sZS5sb2cocmF3RGVmaW5pdGlvbik7XG4gICAgY29uc3QgcmV2ZXJzZUZsYXNoY2FyZCA9IGF0b20uZ2VuZXJhdGVSZXZlcnNlRmxhc2hjYXJkU2VjdGlvbigpO1xuICAgIGNvbnNvbGUubG9nKHJldmVyc2VGbGFzaGNhcmQpO1xufVxuXG5cbmNvbnN0IHdyaXRlUmV2ZXJzZUZsYXNoY2FyZHMgPSAoKSA9PiB7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGZzLnJlYWRkaXIodGVzdEF0b21QYXRoLCAoZXJyLCBmaWxlcykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICBsZXQgYXRvbUZpbGVQYXRoID0gYCR7dGVzdEF0b21QYXRofS8ke2ZpbGV9YFxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhhdG9tRmlsZVBhdGgpO1xuICAgICAgICAgICAgZnMuc3RhdChhdG9tRmlsZVBhdGgsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHN0YXRzOicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0cy5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcy5yZWFkRmlsZShhdG9tRmlsZVBhdGgsICd1dGY4JywgKGVyciwgZmlsZUNvbnRlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlYWRpbmcgdGhlIGZpbGU6JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdG9tID0gbmV3IEF0b20oe30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBhdG9tRmlsZVBhdGguc3BsaXQoJy8nKS5wb3AoKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0b20ucG9wdWxhdGVGcm9tRmlsZShmaWxlTmFtZSwgZmlsZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhhdG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3RGVmaW5pdGlvbiA9IGF0b20ucmF3RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyYXdEZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdG9tLmNyZWF0ZVJldmVyc2VGbGFzaGNhcmQgJiYgYXRvbS5yZXZlcnNlRmxhc2hjYXJkSW5mbyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciA8IG1heEF0b21zVG9Qcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2VGbGFzaGNhcmQgPSBhdG9tLmdlbmVyYXRlUmV2ZXJzZUZsYXNoY2FyZFNlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmV2ZXJzZUZsYXNoY2FyZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvdW50ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzLmFwcGVuZEZpbGVTeW5jKGAke2F0b21GaWxlUGF0aH1gLCBgXFxuJHtyZXZlcnNlRmxhc2hjYXJkfWAsICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNYXggQXRvbXMgUHJvY2Vzc2VkLlNraXBwaW5nICR7YXRvbUZpbGVQYXRofWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTa2lwcGluZyAke2F0b21GaWxlUGF0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyBcbiAgICAgICAgXG4gICAgfSk7XG59XG5cbmNvbnN0IHVwZGF0ZUF0b21zID0gKGF0b21QYXRoOiBzdHJpbmcpID0+IHtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgZnMucmVhZGRpcihhdG9tUGF0aCwgKGVyciwgZmlsZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICAgICAgbGV0IGF0b21GaWxlUGF0aCA9IGAke2F0b21QYXRofS8ke2ZpbGV9YFxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhhdG9tRmlsZVBhdGgpO1xuICAgICAgICAgICAgZnMuc3RhdChhdG9tRmlsZVBhdGgsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHN0YXRzOicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0cy5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhhdG9tRmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdG9tID0gbmV3IEF0b20oe30pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGF0b21GaWxlUGF0aC5zcGxpdCgnLycpLnBvcCgpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnIyMjIyMjIyMjIyMjIyMnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGF0b20ucG9wdWxhdGVGcm9tRmlsZShmaWxlTmFtZSwgZmlsZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBhdG9tLndyaXRlVG9GaWxlKGF0b21GaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhhdG9tLmdlbmVyYXRlQXRvbUNvbnRlbnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vL2NvbnN0IHNlY3Rpb25UZXN0ID0gKGF0b206IEF0b20pID0+IHtcblxuXG4vL2FkZFJldmVyc2VGbGFzaGNhcmRUb0F0b20odGVzdEF0b21QYXRoKTtcbi8vdGVzdFNpbmdsZUF0b20oc2luZ2xlVGVzdEF0b21QYXRoKTtcbi8vd3JpdGVSZXZlcnNlRmxhc2hjYXJkcygpO1xudXBkYXRlQXRvbXModGVzdEF0b21QYXRoKTsiXX0=